<!DOCTYPE HTML>
<html>
  <head>
    <title>melonJS - Space invaders tutorial</title>
    <meta name="description" content="melonJS space invaders tutorial"/>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="style/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <script type="text/javascript">
      //<![CDATA[

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-13050059-3']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script');
        ga.type = 'text/javascript';
        ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(ga, s);
      })();

      //]]>
    </script>
    <script type="text/javascript" src="SyntaxHighlighter/shCore.js"></script>
    <script type="text/javascript" src="SyntaxHighlighter/shBrushJScript.js"></script>
    <link href="SyntaxHighlighter/shCore.css" rel="stylesheet" type="text/css" />
    <link href="SyntaxHighlighter/shThemeDefault.css" rel="stylesheet" type="text/css" />
    <style type="text/css">
      /*<![CDATA[*/
      pre.c2 {
        font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace;
        color: #000000;
        background-color: #eee;
        font-size: 12px;
        border: 1px dashed #999999;
        line-height: 14px;
        padding: 5px;
        overflow: auto;
        width: 100%
      }

      p.c1 {
        font-weight: bold;
        padding: 0;
      }

      /*]]>*/
    </style>
  </head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <a class="navbar-brand" href="#">
            <img src="https://raw.githubusercontent.com/melonjs/melonJS/master/tasks/jsdoc-template/template/static/images/melon.png" alt="melonJS" height='30'>
          </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav">
            <li><a href="http://melonjs.org">Home</a></li>
          </ul>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container-fluid -->
    </nav>
    <!-- the "Fork me!" sticker -->

    <div id="main">
      <div class="row">
        <div id="sidebar" class="col-md-2 col-md-offset-1 sidebar">
          <ul class="nav nav-sidebar">
            <li><h3>Content</h3></li>
            <li><a href="#intro">Introduction</a></li>
            <li><a href="#part1">Setting up our ships</a></li>
            <li><a href="#part2">Applying movement</a></li>
            <li><a href="#part3">Adding Lasers, pew pew!</a></li>
            <li><a href="#part4">Collisions</a></li>
            <li><a href="#part5">Win &amp; Loss Conditions</a></li>
            <li><a href="#challenges">Challenges</a></li>
          </ul>
        </div>

        <div id="content" class="col-md-8 col-md-offset-3 main">
          <h1>Space Invaders Tutorial</h1>
          <p>In this tutorial, we will create a space invaders clone. This tutorial will primarily be focused on creating more game elements through code, and using other APIs that MelonJS provides, that the <a href="http://melonjs.github.io/tutorial-platformer/">platformer tutorial</a> does not cover.</p>

          <!-- INTRO ================================================================== -->
          <div>
            <a id="intro" class="offset-anchor"></a>
            <div class="subcontent">
              <h2>Introduction</h2>
              <p>To work through this tutorial, you need the following:</p>

              <ul>
                <li>
                  The melonJS <a href="https://github.com/melonjs/boilerplate/archive/master.zip">boilerplate</a>, that we will use as default template project for our tutorial.
                </li>
                <li>
                  The tutorial <a href="tutorial_data.zip">image assets</a>, to be uncompressed into the boilerplate data directory. So when you unzip, you should have:
<pre>
data/img/player.png
data/img/ships.png
js/game.js
etc
</pre>
                </li>

                <li>The melonJS <a href="http://www.melonjs.org/download.html"> library</a>. If you downloaded the boilerplate, you will already have this. It should be copied under the /lib directory. You can copy the development version, as the boilerplate provides a minification task.
                </li>

                <li>The melonJS <a href="http://www.melonjs.org/docs/index.html">documentation</a> for more details </li>
              </ul>

              <p>
                <b>Testing/debugging :</b><br/>
                Your best bet is to use a local web server, as for example detailed in the melonJS <a href="https://github.com/melonjs/boilerplate">boilerplate</a> README, by using the `grunt connect` tool, and that will allow you to test your game in your browser using the <a href="http://localhost:8000">http://localhost:8000</a> url.
              </p>
              <p>
                If you just want to use the filesystem, the problem is you'll run into "cross-origin request" security errors. With Chrome, you need to use the "--disable-web-security" parameter or better "--allow-file-access-from-files" when launching the browser. This must be done in order to test any local content, else the browser will complain when trying to load assets through XHR. <strong>Though this method is not recommended.</strong> As long as you have the option enabled, you're adding security vulnerabilities to your session.<br/>
              </p>
            </div>
          </div>

          <!-- Part 1 -->
          <a id="part1" class="offset-anchor"></a>
          <div class="subcontent">
            <h2>Setting up our ships</h2>
            <p>Your directory structure from the boilerplate should look something like this:</p>

<pre>
data/
  img/
    player.png
    ships.png
js/
  game.js
  resources.js
  entities/
    HUD.js
    entities.js
  screens/
    play.js
    title.js
index.html
index.css
</pre>

            <p>The boilerplate provides a bunch of default code. For this tutorial there are some files that we will not need. You can delete the file screens/title.js, and remove the entire js/entities folder. Then update the index.html file to no longer include those, and remove the references of TitleScreen from the game.js file.</p>

            <pre class="brush: js">
              var game = {

                  // Run on page load.
                  "onload" : function () {
                      // Initialize the video.
                      if (!me.video.init(640, 480, {wrapper : "screen", scale : 'auto'})) {
                          alert("Your browser does not support HTML5 canvas.");
                          return;
                      }

                      // add "#debug" to the URL to enable the debug Panel
                      if (me.game.HASH.debug === true) {
                          window.onReady(function () {
                              me.plugin.register.defer(this, me.debug.Panel, "debug", me.input.KEY.V);
                          });
                      }

                      // Initialize the audio.
                      me.audio.init("mp3,ogg");

                      // Set a callback to run when loading is complete.
                      me.loader.onload = this.loaded.bind(this);

                      // Load the resources.
                      me.loader.preload(game.resources);

                      // Initialize melonJS and display a loading screen.
                      me.state.change(me.state.LOADING);
                  },



                  // Run on game resources loaded.
                  "loaded" : function () {
                      // set the "Play/Ingame" Screen Object
                      this.playScreen = new game.PlayScreen();
                      me.state.set(me.state.PLAY, this.playScreen);

                      // start the game
                      me.state.change(me.state.PLAY);
                  }
              };
            </pre>

            <p>Game.js is where the game is bootstrapped. index.html calls the game.onload function after loading all the js files in the window ready event. The <strong>me.video.init</strong> bit creates the canvas tag and gets the video setup.</p><p>Lines 12-16 are for using the debug panel.</p><p>Then we intialize the audio engine, telling it what formats we are supporting for this game.</p>

            <p>We set a callback on <strong>me.loader</strong> to our loaded function, and then tell what assets it needs to load, via an array.</p>

            <p>The final step of this process is setting the state of the game to loading.</p>
            <aside>
              <h5>Note</h5>
              <p>Game states can be used to for things like a menu screen, play screen, pause screen, etc. When changing state, it's important to note that everything is removed from the game world, unless you have it set to be <a href="http://melonjs.github.io/docs/me.Renderable.html#isPersistent" target="_blank">persistent</a> across states.</p>
            </aside>

            <pre class="brush: js">
              "loaded" : function () {
                  this.playScreen = new game.PlayScreen();
                  me.state.set(me.state.PLAY, this.playScreen);

                  // start the game
                  me.state.change(me.state.PLAY);
              }
            </pre>

            <p>The loaded function then sets up the playscreen and tells the game to use that screen object for the play state.</p>
            <p>Then the game state is set to PLAY.</p>

            <h4>Back to space invaders</h4>

            <p>The first thing to add is images to the resources.js file.</p>
            <pre class="brush: js">
              game.resources = [
                { name: "player", type: "image", src: "data/img/player.png" },
                { name: "ships", type: "image", src: "data/img/ships.png" }
              ];
            </pre>
            <p>This variable is the one passed to me.loader.preload in game.js</p>

            <p>The structure for an asset is :</p>
            <table>
              <tr>
                <td>name</td>
                <td>The name of the asset you wish to use in your game. A string key.</td>
              </tr>
              <tr>
                <td>type</td>
                <td>The type of the asset. Valid types are: <strong>audio, binary, image, json, tmx, tsx</strong>. Binary is a good solution for loading raw text, or any other format not listed. TMX &amp; TSX are for tiled file formats. Whether it be the xml or json format.</td>
              </tr>
              <tr>
                <td>src</td>
                <td>The path to the asset, relative from index.html. For audio you need specify the folder instead of direct path.</td>
              </tr>
            </table>

            <p>Open <strong>js/screens/play.js</strong> and empty the code from the two methods: <strong>onResetEvent</strong> and <strong>onDestroyEvent</strong>. Then save, and then open the game in your web browser.</p>

            <p>There is not much to see yet. Let's change that.</p>

            <p>First thing is to create a player entity.</p>

            <p>Add a new file under the js folder, and call it <strong>player.js</strong>. Be sure to add it in the index.html file.</p>

            <pre class="brush: js">
              game.Player = me.Sprite.extend({
                  init: function () {
                      var image = me.loader.getImage("player");
                      this._super(me.Sprite, "init", [me.game.viewport.width / 2 - image.width / 2, me.game.viewport.height - image.height - 20, { image: image }]);
                  }
              });
            </pre>
            <p>
              So what we're doing is adding a function to the window.game object that extends <strong>me.Sprite</strong>. It sets up an init method that grabs the player image.</p>
            <p>For the x coordinate, we simply grab the dead center, and subtract half the ship, so it can be positioned in the center. And then set its y property to be 20 pixels above the bottom. Then finally pass the image instance to it.</p>

            <p>Calling <strong>this._super</strong> is how we reference a parent classes' method. In this case, we're calling the me.Sprite contrusctor.</p>
            <p>Let's setup the player in the entity pool. Open game.js and add the following at the top of the loaded method:</p>
            <pre class="brush: js">
              me.pool.register("player", game.Player);
            </pre>
            <p>
              Now open up <strong>js/screens/play.js</strong>, and edit the onResetEvent method so it looks like this:
            </p>

            <pre class="brush: js">
              game.PlayScreen = me.ScreenObject.extend({
                  /**
                   *  action to perform on state change
                   */
                  onResetEvent: function() {
                      me.game.world.addChild(me.pool.pull("player"));
                  },


                  /**
                   *  action to perform when leaving this screen (state change)
                   */
                  onDestroyEvent: function() {
                  }
              });

            </pre>

            <p>The <strong>onResetEvent</strong> is called when this state is loaded. So when invoking</p>
            <pre class="brush: js">
              me.state.change(me.state.PLAY);
            </pre>

            <p>In the game.js file, <strong>onResetEvent</strong> is then called.</p>

            <img src="screens/screenone.png" />

            <p>Yay, the ship is on the bottom of the screen!
            </p><p>But we can still see the loading bar, that's not cool. The reason for this is that MelonJS does not want to do any operations that it doesn't have to. Sometimes you'll have a background image that gets redrawn, so it covers the original loading bar. However, we don't have a background image for this game, so what we will do is add a color layer.</p>

            <pre class="brush: js">
              me.game.world.addChild(new me.ColorLayer("background", "#000000", 0));
            </pre>
            <p>
              Add that in the play screen, above the line where we added the player. The first parameter is simply the name for the layer, so it's easy to fetch from the game world later if you need to.</p><p>The second parameter is the color to draw in hex.</p>
              <p>The last is the z index. We want it to draw first, so we set it at zero. The z-index can also be passed with addChild:
            </p>
            <pre class="brush: js">
              me.game.world.addChild(new me.ColorLayer("background", "#000000"), 0);
            </pre>

            <p>Now the pesky loading bar should be gone. Time to add in an enemy. Create a new file under the js folder called enemy.js, and add it to the index.html file.</p>

            <p>Since enemies will have to collide with things like the player's laser, it should extend <strong>me.Entity</strong> as opposed to <strong>me.Sprite</strong>, so lets get that going:</p>
            <pre class="brush: js">
              game.Enemy = me.Entity.extend({
                  init: function (x, y) {
                      this._super(me.Entity, "init", [x, y, {
                          image: "ships",
                          width: 32,
                          height: 32
                      }]);
                  }
              });
            </pre>

            <p>With the enemy, we will need to place them in different spots, so x &amp; y will be added to its constructor, and then passed along to the me.Entity's constructor. The third parameter in the array is a hash of settings. The settings specifies the image as "ships", referencing our game.resources array. The width and height are set to 32x32.</p>

            <p>In game.js, add the enemy to the entity pool:</p>

            <pre class="brush: js">
              me.pool.register("enemy", game.Enemy);
            </pre>

            <p>Back in play.js, add an enemy to the game world. Your play.js should now look like:</p>
            <pre class="brush: js">
              game.PlayScreen = me.ScreenObject.extend({
                  /**
                   *  action to perform on state change
                   */
                  onResetEvent: function() {
                      me.game.world.addChild(new me.ColorLayer("background", "#000000", 0));
                      me.game.world.addChild(me.pool.pull("player"));
                      me.game.world.addChild(me.pool.pull("enemy"));
                  },


                  /**
                   *  action to perform when leaving this screen (state change)
                   */
                  onDestroyEvent: function() {
                  }
              });

            </pre>
            <p>You can put the enemy at any x &amp; y to try it out. Save &amp; refresh the page in your browser.</p>

            <p>You'll likely notice that the ship is constantly changing how it looks. If you open the ships.png file under data/img, you can see that it is a sprite sheet containing 4 different ships. <strong>me.Entity</strong> for its renderable uses the <strong>me.AnimationSheet</strong> class. Since we didn't add and set any animations on the renderable property, it is just looping through each &amp; every frame. Let's fix that.</p>

            <p>Add a new method to our enemy:</p>
            <pre class="brush: js">
              chooseShipImage: function () {
                  var frame = ~~(Math.random() * 3);
                  this.renderable.addAnimation("idle", [frame], 1);
                  this.renderable.setCurrentAnimation("idle");
              }
            </pre>

            <p>The first line simply randomizes which frame we want. The ship is 32x32, the image is 64x64, so we have 4 frames. ~~ is a shortcut for Math.floor when the number is 0 or positive. On negative numbers, it works like Math.ceil.</p>
            <p>The second line is accessing the animation sheet instance (this.renderable), and uses the addAnimation function to add a new idle frame. So we simply specify the index that was generated at random.</p>
            <p>With the final line, we set the current animation to idle.</p>
            <p>Now call the function at the bottom of the constructor, like so:</p>
            <pre class="brush: js">
              game.Enemy = me.Entity.extend({
                  init: function (x, y) {
                      this._super(me.Entity, "init", [x, y, {
                          image: "ships",
                          width: 32,
                          height: 32
                      }]);
                      this.chooseShipImage();
                  },

                  chooseShipImage: function () {
                      var frame = ~~(Math.random() * 3);
                      this.renderable.addAnimation("idle", [frame], 1);
                      this.renderable.setCurrentAnimation("idle");
                  },
              });
            </pre>
            <p>Now refresh the page, and our ship should only pop up as one of them. Try refreshing it multiple times to see it change.</p>
          </div>

          <!-- Part 2 -->
          <a id="part2" class="offset-anchor"></a>
          <div class="subcontent">
            <h2>Applying Movement</h2>
            <p>Now that we have ships on screen, let's actually get some interaction going.</p>

            <p>Back in play.js, lets add some keybindings:</p>
            <pre class="brush: js">
              game.PlayScreen = me.ScreenObject.extend({
                  /**
                   *  action to perform on state change
                   */
                  onResetEvent: function() {
                      me.game.world.addChild(new me.ColorLayer("background", "#000000", 0));
                      me.game.world.addChild(new game.Player(), 1);
                      me.game.world.addChild(new game.Enemy(50, 50), 2);

                      me.input.bindKey(me.input.KEY.LEFT, "left");
                      me.input.bindKey(me.input.KEY.RIGHT, "right");
                      me.input.bindKey(me.input.KEY.A, "left");
                      me.input.bindKey(me.input.KEY.D, "right");
                  },


                  /**
                   *  action to perform when leaving this screen (state change)
                   */
                  onDestroyEvent: function() {
                      me.input.unbindKey(me.input.KEY.LEFT);
                      me.input.unbindKey(me.input.KEY.RIGHT);
                      me.input.unbindKey(me.input.KEY.A);
                      me.input.unbindKey(me.input.KEY.D);
                  }
              });
            </pre>

            <p>The method calls here are pretty straight forward. We bind a keypress to an action name. Multiple keys can be assigned to a single action name.</p>

            <p>It's typically a good game design practice to offer multiple key bindings. Even a better practice make it configurable. You always need to keep in mind people who are left handed or who have different layouts.</p>

            <p>You might also noticed i added the <strong>z index</strong> option to the addChild calls. It's a pretty good practice, because that way you ensure your draw order.</p>

            <p>The <strong>onDestroyEvent</strong> removes the events when changing state. Not something we actually need, because we only have the play state after loading. But a good practice to keep in mind.</p>

            <p>Now that we have bindings, let's implement player movement. Add the following update function to the player class:</p>

            <p>Then add a velx property to the player in its init method, as well as the furthest x position it can go on screen (maxX):</p>

            <pre class="brush: js">
              init: function () {
                  var image = me.loader.getImage("player");
                  this._super(me.Sprite, "init", [me.game.viewport.width / 2 - image.width / 2, me.game.viewport.height - image.height - 20, image]);
                  this.velx = 450;
                  this.maxX = me.game.viewport.width - this.width;
              },
            </pre>

            <p>Then modify the update method to check for the key events, and move the player accordingly.</p>

            <pre class="brush: js">
              update: function (time) {
                  this._super(me.Sprite, "update", [time]);
                  if (me.input.isKeyPressed("left")) {
                    this.pos.x -= this.velx * time / 1000;
                  }

                  if (me.input.isKeyPressed("right")) {
                    this.pos.x += this.velx * time / 1000;
                  }

                  this.pos.x = this.pos.x.clamp(0, this.maxX);

                  return true;
              }
            </pre>

            <p>Update functions of our game objects will always receive a delta time (in milliseconds). It's important to pass it along to our parent's class update.</p>

            <pre class="brush: js">this._super(me.Sprite, "update", [time]);</pre>

            <p>After that, it's a matter of checking if the <strong>left</strong> action is currently pressed. Using the velocity value set earlier, we simply subtract the velocity value, multiplied by the delta in seconds.</p>

            <pre class="brush: js">
              if (me.input.isKeyPressed("left")) {
                this.pos.x -= this.velx * time / 1000;
              }
            </pre>

            <p>To move right, we check for the <strong>right</strong> action, and add the velocity value to our x position.</p>

            <pre class="brush: js">
              if (me.input.isKeyPressed("right")) {
                this.pos.x += this.velx * time / 1000;
              }
            </pre>

            <aside>
              <h5>Note</h5>
              <p>The reason for use of delta time, is to have consistent transformations across various frame rates. If you have pos.x += 5; in your update, and run at 1 frame per second, the player will move 5 pixels once per second. If you have 30 fps, the player will move at 150 pixels per second. The delta time is used to level the playing field. The less fps you have, the more jumpy it will look.</p>
            </aside>

            <p>We then use <strong>clamp</strong> to ensure the x value does not go outside the screen.</p>

            <pre class="brush: js">this.pos.x = this.pos.x.clamp(0, this.maxX);</pre>

            <p>The return value tells melon whether a re-draw is required. This can be useful to dictate for when an animation sheet needs to animate on a given frame. However, this is a single sprite, so we can just tell it to redraw.</p>
            <pre class="brush: js">return true;</pre>

            <p>Save the file &amp; refresh your browser. Try using A/D or the Left &amp; Right arrow keys to move.</p>

            <h4>Enemy movement</h4>

            <p>A defining characteristic of space invaders is that all the ships move in one direction, shift down and then go in the other direction. They all move together. We could take the velocity logic that we used for the player, and apply it to the enemy class. But we can better leverage MelonJS to do this for us. Time to use our own subclass of <strong>me.Container</strong></p>

            <p>Objects inside a container are relative to its parent. So when we move the container, all objects inside shift with it. This applies to rotation &amp; scale operations as well. So let's create one.</p>

            <p>Create a new file: js/enemy_manager.js, and add it to the index.html.</p>

            <pre class="brush: js">
              game.EnemyManager = me.Container.extend({
                init: function () {
                  this.COLS = 9;
                  this.ROWS = 4;
                  this._super(me.Container, "init", [0, 32, this.COLS * 64 - 32, this.ROWS * 64 - 32]);
                }
              });
            </pre>

            <p>Essentially what we're setting up here is the start position and the base width. Starting the container 32 pixels down, and at 0 left (or x).</p>

            <p>We're allotting 64 pixels per ship width &amp; height wise. Then subtracting 32 pixels because the last row &amp; column does not require the side padding.</p>

            <p>For adding enemies to our container, we need another method:</p>

            <pre class="brush: js">
              createEnemies: function () {
                  for (var i = 0; i < this.COLS; i++) {
                      for (var j = 0; j < this.ROWS; j++) {
                          this.addChild(me.pool.pull("enemy", i * 64, j * 64));
                      }
                  }
              }
            </pre>

            <p>Generating 9 columns, and 4 rows: 36 ships.</p>
            <p>Now in play.js, remove the addChild for the enemy, and set a property to an enemy manager. Below that invoke createEnemies, and add it to the game world.</p>
            <pre class="brush: js">
              onResetEvent: function() {
                  me.game.world.addChild(new me.ColorLayer("background", "#000000", 0));
                  me.game.world.addChild(me.pool.pull("player"), 1);

                  this.enemyManager = new game.EnemyManager();
                  this.enemyManager.createEnemies();
                  me.game.world.addChild(this.enemyManager, 2);


                  me.input.bindKey(me.input.KEY.LEFT, "left");
                  me.input.bindKey(me.input.KEY.RIGHT, "right");
                  me.input.bindKey(me.input.KEY.A, "left");
                  me.input.bindKey(me.input.KEY.D, "right");
                  me.input.bindKey(me.input.KEY.SPACE, "shoot", true);
              }
            </pre>

            <p>Once you save and refresh, you should see a bunch of random ships.</p>
            <img src="screens/screentwo.png" alt="" />
            <p>For movement, let's keep it simple and have the container move once per second. For this, we can use a melonjs timer.</p>

            <p>Add these two methods to the enemy_screen.js</p>
            <pre class="brush: js">
              onActivateEvent: function () {
                  var _this = this;
                  this.timer = me.timer.setInterval(function () {
                      _this.pos.x += _this.vel;
                  }, 1000);
              },

              onDeactivateEvent: function () {
                  me.timer.clearInterval(this.timer);
              }
            </pre>
            <p>And then set the vel property in the init method to 16:</p>
            <pre class="brush: js">
              this.vel = 16;
            </pre>

            <p><strong>onActivateEvent</strong> is called (if it's defined) when the object is added to the game world. This goes for any object you pass to addChild on a container. Likewise, <strong>onDeactivateEvent</strong> is called when the object is removed from the game world.</p>

            <p>Using the MelonJS version of <strong>setInterval</strong> (which is built into the game loop, it does not use window.setInterval), we can then increment the x position.</p>

            <p>Save and refresh the browser. The enemy ships now all move together, however they just kinda drift off screen, and don't move down. So let's improve the code adjusting the container position.</p>

            <p>First we need to add a rectangle property to track the size of the container:</p>

            <pre class="brush: js">
              this.childBounds = this.getBounds().clone();
            </pre>

            <p>This takes the current defaults bounds and clones it to a new instance of <strong>me.Rect</strong></p>

            <p>Then lets re-implement the <strong>addChild</strong> method to update this new rectangle:</p>

            <pre class="brush: js">
              addChild: function (child, z) {
                  this._super(me.Container, "addChild", [child, z]);
                  this.resizeChildBounds();
              }
            </pre>

            <p>Then add the <strong>removeChildNow</strong> counterpart:</p>

            <pre class="brush: js">
              removeChildNow: function (child) {
                  this._super(me.Container, "removeChildNow", [child]);
                  this.resizeChildBounds();
              }
            </pre>

            <p>The reason for extending <strong>removeChildNow</strong> instead of <strong>removeChild</strong>, is removeChild is called after the current frame finishes. removeChildNow is the method that actually removes the object, and we want to resize the bounds after the object has been removed.</p>

            <p>Now add the <strong>resizeChildBounds</strong> method to the enemy_manager:</p>

            <pre class="brush: js">
              resizeChildBounds: function () {
                  this.childBounds.pos.set(Infinity, Infinity);
                  this.childBounds.resize(-Infinity, -Infinity);
                  for (var i = this.children.length, child; i--, (child = this.children[i]);) {
                      if (child.isRenderable) {
                          this.childBounds.union(child);
                      }
                  }
              }
            </pre>

            <p>What this does is uses the <strong>union</strong> method of <strong>me.Rect</strong> to determine the minimum bounds that contains all the children. This will determine the width &amp; height values of our container.</p>

            <pre class="brush: js">
              onActivateEvent: function () {
                  var _this = this;
                  this.timer = me.timer.setInterval(function () {
                      var bounds = _this.childBounds;
                      var right = _this.pos.x + bounds.right;
                      var left = _this.pos.x;

                      if ((_this.vel > 0 && (right + _this.vel) >= me.game.viewport.width) || (_this.vel < 0 && (left + _this.vel) <= 0)) {
                          _this.vel *= -1;
                          _this.pos.y += 16;
                          if (_this.vel > 0) {
                              _this.vel += 5;
                          }
                          else {
                              _this.vel -= 5;
                          }
                      }
                      else {
                          _this.pos.x += _this.vel;
                      }
                  }, 1000);
              }
            </pre>

            <p>That's a fair bit of code, so let's break it down.</p>

            <p>Using the child bounds, we setup the left &amp; right values to world coordinates.</p>
            <pre class="brush: js">
              var bounds = _this.childBounds;
              var right = _this.pos.x + bounds.right;
              var left = _this.pos.x;
            </pre>

            <p>The first part of the if checks if the container is moving right, and the right edge + velocity is outside the viewport.</p>
            <pre class="brush: js">(_this.vel > 0 && (right + _this.vel) >= me.game.viewport.width)</pre>
            <p>The second part checks if the container is moving left, and its left bounds is less than zero.</p>
            <pre class="brush: js">(_this.vel < 0 && (left + _this.vel) <= 0)</pre>

            <p>In the block, we reverse the velocity, move down by 16 pixels and then increase the velocity.</p>

            <pre class="brush: js">
              _this.vel *= -1;
              _this.pos.y += 16;
              if (_this.vel > 0) {
                  _this.vel += 5;
              }
              else {
                  _this.vel -= 5;
              }
            </pre>
            <p>Then the last bit, we increment the velocity if the container hasn't moved left or right</p>
            <pre class="brush: js">
              else {
                  _this.pos.x += _this.vel;
              }
            </pre>
            <p>Save and refresh this time, it will now move back and forth across the screen, closer to our player.</p>
          </div>

          <!-- Part 3 -->

          <a id="part3" class="offset-anchor"></a>
          <div class="subcontent">
            <h2>Adding Lasers, pew pew!</h2>
            <p>Time to get some actual &ldquo;game&rdquo; in this game.</p>
            <p>First thing to do is open up your play.js file, and add a new keybind &amp; unbind:</p>

            <pre class="brush: js">
              me.input.bindKey(me.input.KEY.SPACE, "shoot", true);
            </pre>

            <pre class="brush: js">
              me.input.unbindKey(me.input.KEY.SPACE);
            </pre>

            <p>The reason for the boolean in the <strong>bindKey</strong> call is to only allow on register per key press. So in order to shoot twice, the player must press the space bar, release it, and then press it again.</p>

            <p>Before we wire up the player to shoot, we need a laser. Create a laser.js file, and add the following code to it. As always, be sure to add the laser.js script tag in the index.html file.</p>

            <pre class="brush: js">
              game.Laser = me.Entity.extend({
                  init: function (x, y) {
                      this._super(me.Entity, "init", [x, y, { width: game.Laser.width, height: game.Laser.height }]);
                      this.z = 5;
                      this.body.addShape(new me.Rect(0, 0, this.width, this.height));
                      this.body.updateBounds();
                      this.body.setVelocity(0, 300);
                      this.body.collisionType = me.collision.types.PROJECTILE_OBJECT;
                      this.renderable = new (me.Renderable.extend({
                          init: function () {
                              this._super(me.Renderable, "init", [0, 0, game.Laser.width, game.Laser.height]);
                          },
                          destroy: function () {},
                          draw: function (renderer) {
                              var color = renderer.globalColor.toHex();
                              renderer.setColor('#5EFF7E');
                              renderer.fillRect(0, 0, this.width, this.height);
                              renderer.setColor(color);
                          }
                      }));
                      this.alwaysUpdate = true;
                  },

                  update: function (time) {
                      this.body.vel.y -= this.body.accel.y * time / 1000;
                      if (this.pos.y + this.height <= 0) {
                          me.game.world.removeChild(this);
                      }

                      this.body.update();
                      me.collision.check(this);

                      return true;
                  }
              });

              game.Laser.width = 5;
              game.Laser.height = 28;
            </pre>

            <p>So lets go through it. At the bottom, we have set two properties of width & height for the laser, so it can easily be re-used.</p>

            <pre class="brush: js">
              game.Laser.width = 5;
              game.Laser.height = 28;
            </pre>


            <p>Traditional stuff here. Setup the x &amp; y position from its parameters, and a width+height properties. A bit different from our other objects, we have set the z index on the object manually. This is an alternative to passing the z index in the addChild call.</p>
            <pre class="brush: js">
              this._super(me.Entity, "init", [x, y, { width: game.Laser.width, height: game.Laser.height }]);
              this.z = 5;
            </pre>

            <p>These next methods for setting up a collision body.</p>
            <pre class="brush: js">
              this.body.addShape(new me.Rect(0, 0, this.width, this.height));
              this.body.updateBounds();
              this.body.setVelocity(0, 300);
              this.body.collisionType = me.collision.types.PROJECTILE_OBJECT;
            </pre>

            <p>The first adds a shape. While me.Entity creates a body for you, it does not assume a default shape. When creating an object in tiled, you are creating a shape, so that is provided as the default. We're not using tiled, so we shall create a rectangle.</p>
            <pre class="brush: js">this.body.addShape(new me.Rect(0, 0, this.width, this.height));</pre>
            <p><strong>updateBounds()</strong> re-calculates the AABB bounds based off the shape we added.</p>
            <pre class="brush: js">this.body.updateBounds();</pre>
            <p>Now we set a velocity. Velocity is a vector, and we want the laser to move up. So set a velocity of 30. Note that velocity should never be negative to dictate direction.</p>
            <pre class="brush: js">this.body.setVelocity(0, 300);</pre>
            <p>Then we set a collision type. This is useful in collision callbacks.</p>
            <pre class="brush: js">this.body.collisionType = me.collision.types.PROJECTILE_OBJECT;</pre>

            <p>This is a fairly meaty bit of the code. <strong>me.Renderable</strong> is the base drawing class in melon. It gives the minimum setup required to be a valid drawing object in the game world.</p>
            <pre class="brush: js">
              this.renderable = new (me.Renderable.extend({
                  init: function () {
                      this._super(me.Renderable, "init", [0, 0, game.Laser.width, game.Laser.height]);
                  },
                  draw: function (renderer) {
                      var color = renderer.globalColor.toHex();
                      renderer.setColor('#5EFF7E');
                      renderer.fillRect(0, 0, this.width, this.height);
                      renderer.setColor(color);
                  }
              }));
            </pre>

            <p>The init is pretty traditional, we set the x &amp; y to zero, as this is going to be relative to the laser entity. Use the same width &amp; height as the entity itself.</p>

            <pre class="brush: js">
              init: function () {
                  this._super(me.Renderable, "init", [0, 0, game.Laser.width, game.Laser.height]);
              },
            </pre>

            <p>Then we implement the draw method. The classes we've used so far have provided a working draw method for our purposes, now we're going to use the renderer to draw something by hand.</p>

            <pre class="brush: js">
              draw: function (renderer) {
                  var color = renderer.globalColor.toHex();
                  renderer.setColor('#5EFF7E');
                  renderer.fillRect(0, 0, this.width, this.height);
                  renderer.setColor(color);
              }
            </pre>

            <p>The renderer can be either <strong>me.CanvasRenderer</strong> or <strong>me.WebGLRenderer</strong>, depending on your settings in <strong>me.video.init</strong>. The renderer provides basic drawing operations.</p>

            <pre class="brush: js">draw: function (renderer)</pre>


            <p>So we first get a reference of the original color. <strong>globalColor</strong> is an instance of <strong>me.Color</strong>.</p>
            <pre class="brush: js">var color = renderer.globalColor.toHex();</pre>
            <p>Set the color to a nice laser green.</p>
            <pre class="brush: js">renderer.setColor('#5EFF7E');</pre>
            <p>Then use a fill rect number. Again, 0, 0 is relative. Then use the width &amp; height to dictate the size of the rect we're filling</p>
            <pre class="brush: js">renderer.fillRect(0, 0, this.width, this.height);</pre>
            <p>Then set the color back. This is important so our other draw calls will not be effected by the colour change.</p>
            <pre class="brush: js">renderer.setColor(color);</pre>

            <p>The final step for our Laser's init method:</p>
            <pre class="brush: js">
              init: function (x, y) {
                  // ...
                  this.alwaysUpdate = true;
              }
            </pre>

            <p>The <strong>alwaysUpdate</strong> property is to be avoided as much as possible. It will update an object when it is outside the viewport. The reason to use it in this game is because we don't want to remove the laser until it is offscreen. If we wait until it's offscreen, and alwaysUpdate is false, it will never get removed.</p>

            <p>Speaking of the update method.</p>

            <pre class="brush: js">
              update: function (time) {
                  this.body.vel.y -= this.body.accel.y * time / 1000;
                  if (this.pos.y + this.height <= 0) {
                      me.game.world.removeChild(this);
                  }

                  this.body.update();
                  me.collision.check(this);

                  return true;
              }
            </pre>

            <p>The first bit is how we will move the laser. The ship was just moved by manipulating the position directly. Since this has a collision body, we will manipulate the y velocity, by subtracting the y acceleration.</p>

            <pre class="brush: js">this.body.vel.y -= this.body.accel.y * time / 1000;</pre>

            <p>If the position of the laser plus the height (so the bottom of the laser) is less than zero, we can remove the laser from the game world. Again, this will function now work because alwaysUpdate is set to true.</p>
            <pre class="brush: js">
              if (this.pos.y + this.height <= 0) {
                  me.game.world.removeChild(this);
              }
            </pre>

            <p>The body update is very important, this applies the velocity we set for this frame.</p>
            <pre class="brush: js">this.body.update();</pre>
            <p>Then we tell MelonJS to check collisions against this object with <strong>me.collision.check(this)</strong>.</p>
            <pre class="brush: js">me.collision.check(this);</pre>

            <p>The next step for this feature, is to add the laser to the entity pool. Add the following code to game.js, same as the Player &amp; Enemy objects.</p>

            <pre class="brush: js">
              me.pool.register("laser", game.Laser);
            </pre>

            <p>Then back in the player.js file, add the laser shooting in the update method:</p>

            <pre class="brush: js">
              if (me.input.isKeyPressed("shoot")) {
                  me.game.world.addChild(me.pool.pull("laser", this.pos.x + (this.width / 2 - game.Laser.width / 2), this.pos.y - game.Laser.height))
              }
            </pre>

            <p>Reload the game, and try shooting. You should see the lasers fire. However they don't collide with anything.</p>

            <img src="screens/screenthree.png" />
          </div>

          <a id="part4" class="offset-anchor"></a>
          <div class="subcontent">
            <h2>Collisions</h2>
            <p>First lets give our Enemy a physics body. Append this to the init method in enemy.js</p>
            <pre class="brush: js">
              this.body.addShape(new me.Rect(0, 0, 32, 32));
              this.body.setVelocity(0, 0);
              this.body.collisionType = me.collision.types.ENEMY_OBJECT;
            </pre>

            <p>Then add an update method so we can update the body:</p>

            <pre class="brush: js">
              update: function (time) {
                  this._super(me.Entity, "update", [time]);

                  this.body.update();

                  return true;
              }
            </pre>

            <p>Now lets add a collision handler to the laser.js file.</p>

            <pre class="brush: js">
              onCollision: function (res, other) {
                  if (other.body.collisionType === me.collision.types.ENEMY_OBJECT) {
                      me.game.world.removeChild(this);
                      game.playScreen.enemyManager.removeChild(other);
                      return false;
                  }
              }
            </pre>

            <p>The res parameter that we are not using, is simply the collision result. So it contains details on how much overlap there was, where the collision was, etc.</p>

            <p>Since we set the collision type on the Enemy's body to be an <strong>ENEMY_OBJECT</strong>, we can check for that type on the object the laser collided with.</p>
            <pre class="brush: js">if (other.body.collisionType === me.collision.types.ENEMY_OBJECT) {</pre>

            <p>Then we remove the enemy from the laser, along with the enemy from the enemyManager container.</p>
            <pre class="brush: js">
              me.game.world.removeChild(this);
              game.playScreen.enemyManager.removeChild(other);
            </pre>
            <p>The return false in this case isn't strictly necessary, but it's important to point out. When you return false from a collision handler in MelonJS, the object will pass through. If you return true, it will do a hard stop.</p>

            <p>Save the changes, and reload your browser. You should now be able to take out the enemy ships.</p>
            <p>Next step, is adding the win &amp; loss conditions.</p>
          </div>

          <a id="part5" class="offset-anchor"></a>
          <div class="subcontent">
            <h2>Win &amp; Loss Conditions</h2>
            <p>The final step to this game is to actually add conditions for winning &amp; losing. The conditions themselves will be pretty straight forward. When the ships get within range of the player, the player loses. When the player destroys all the enemy ships, they win.</p>

            <p>So what happens when the game ends? A lot of the time you want to display a screen of some sort that the player lost or won. To keep this simple and show you another little trick, we'll just reset the game. So it starts over.</p>

            <h4>First, we'll do the loss condition</h4>

            <p>The pseudo code for this will be:</p>

            <pre class="brush: js">
              if enemy manager overlaps player
                then end game
              else
                continue
              end
            </pre>
            <p>The PlayScreen is our current game state. It holds the reference to the player, and it has the ability to reset the state. So let's add the logic for checking a lose condition there.</p>

            <pre class="brush: js">
              checkIfLoss: function (y) {
                  if (y >= this.player.pos.y) {
                      this.reset();
                  }
              },
            </pre>

            <p>Add that above the <strong>onResetEvent</strong> method. It accepts a Y value, and checks if it has surpassed the player. Then calls its reset method. The reset will wipe out every object from the game world, and reload the state. So it re-invokes <strong>onResetEvent</strong>, re-populating the enemies and player.</p>

            <p>To call it, simply add it to our interval in the enemy manager:</p>

            <pre class="brush: js">
              this.timer = me.timer.setInterval(function () {
                  var bounds = _this.childBounds;
                  var right = _this.pos.x + bounds.right;
                  var left = _this.pos.x;

                  if ((_this.vel > 0 && (right + _this.vel) >= me.game.viewport.width) || (_this.vel < 0 && (left + _this.vel) <= 0)) {
                      _this.vel *= -1;
                      _this.pos.y += 16;
                      if (_this.vel > 0) {
                          _this.vel += 5;
                      }
                      else {
                          _this.vel -= 5;
                      }
                  }
                  else {
                      _this.pos.x += _this.vel;
                  }
                  game.playScreen.checkIfLoss(_this.pos.y + _this.childBounds.bottom);
              }, 1000);
            </pre>

            <p>Since we're checking in the <strong>checkIfLoss</strong> method if the passed number is greater than the Y position of the player, we need to pass the bottom edge of the container. So we use the bounds.bottom and add the y position to it.</p>

            <p>Save and refresh the browser. Let the enemies move around for a minute, and watch the game reset.</p>

            <h4>The Win Condition</h4>

            <p>Likewise, we'll just have the game reset once the player wins. Since we want to cause the win once all the ships are gone, we can check the length of the children on enemy manager.</p>

            <p>First add this boolean to the bottom of the <strong>createEnemies</strong> method:</p>
            <pre class="brush: js">
              this.createdEnemies = true;
            </pre>

            <p>Add the following update method to the enemy manager:</p>
            <pre class="brush: js">
              update: function (time) {
                  if (this.children.length === 0 && this.createdEnemies) {
                    game.playScreen.reset();
                  }
                  this._super(me.Container, "update", [time]);
              }
            </pre>

            <p>This is pretty simple. Children is an array, so we check its length to be zero, and ensure it has created enemies first. Without the boolean check, the game could keep resetting itself because it has no children yet.</p>

            <p>Save and refresh the browser. Try to take out all the ships in time, and see the game reset.</p>
          </div>

          <a id="challenges" class="offset-anchor"></a>
          <div class="subcontent">
            <h2>Challenges</h2>

            <p>We left some parts out of this tutorial, so you could explore them yourself. This is an important part of programming and game development.</p>
            <p>If you get stuck on any of the challenges or parts of the tutorial, please search for the problem, or ask us the question on our forum: <a href="https://groups.google.com/forum/#!forum/melonjs">https://groups.google.com/forum/#!forum/melonjs</a></p>

            <h3>Challenge #1</h3>
            <h4>Add a proper win &amp; loss screen</h4>
            <ol>
              <li>These screens can be made by adding additional ScreenObjects to the game, register them in game.js, and then changing state. For what states to use for the win &amp; screen, look at the states available: <a href="http://melonjs.github.io/docs/me.state.html">http://melonjs.github.io/docs/me.state.html</a></li>
              <li>The win and loss screen can contain a sprite, or text, or both. Whatever you wish really. Be sure to look at <a href="http://melonjs.github.io/docs/me.Font.html">me.Font</a> and <a href="http://melonjs.github.io/docs/me.Sprite.html">me.Sprite</a>. To display a <strong>me.Font</strong> object, use an instance of <strong>me.Renderable</strong> that contains an instance of me.Font, and implement the draw function to invoke me.Font#draw.</li>
              <li>Adjust the checkIfLoss method to show your new loss screen instead.</li>
              <li>Adjust the if block in the update method on EnemyManager, to change state to your win screneobject.</li>
              <li>Even more bonus, add a menu screen that tells the player how to play.</li>
            </ol>

            <h3>Challenge #2</h3>
            <h4>Add a UI</h4>
            <ol>
              <li>Add an enemy counter, and enemy velocity to the top right/left corner of the screen. These properties can be retrieved via: <strong>game.playScreen.enemyManager.children.length</strong> <strong>game.playScreen.enemyManager.vel</strong></li>
              <li>Again look at <a href="http://melonjs.github.io/docs/me.Font.html">me.Font</a>, and implement a renderable for drawing text. Try to only use one class that extends renderable that can be used for both UI pieces.</li>
              <li>Add a score element. Keep track of the score on the play screen. Update it each time an enemy is killed. Remember that enemies are removed from the collision handler on the laser.</li>
            </ol>

            <h3>Challenge #3</h3>
            <h4>Add the concept of levels</h4>
            <ol>
              <li>After you defeat a wave, instead of refreshing the same wave, do a new wave the starts faster. The main logic here will be keeping wave count on the game.js, and increase it after each win. Then use that count in the enemy manager to configure the velocity.</li>
              <li>Have each wave progress faster too (+ 8 each Y increment over + 5 for example). Play with the numbers a bit until it feels right.</li>
            </ol>
          </div>

        </div> <!-- end content -->
      </div> <!-- end row -->
    </div> <!-- end container -->

    <script type="text/javascript">
      SyntaxHighlighter.all();
    </script>
  </body>
</html>
